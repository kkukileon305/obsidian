# 개발자 공통 질문 - type1

### **자료구조와 알고리즘**

- **배열과 연결 리스트의 차이점은 무엇인가요? 각각의 장단점에 대해 설명해 주세요**
> 배열(Array)은 크기가 미리 정해진 정적 자료구조입니다. 크기에 해당하는 연속된 메모리 주소를 할당 받게 됩니다. 연속된 메모리 주소에 해당하는 index를 가지고 있습니다. 장점으로 index를 가지고 있기 때문에 임의 접근이 가능하여 접근과 탐색에 유리합니다. 하지만 단점으로 크기를 미리 정해두었기 때문에 수정하는 것이 불가능하며 해당 크기보다 큰 데이터를 저장 할 수 없습니다.

> 연결 리스트(Linked List)는 배열과 다르게 크기를 정할 필요가 없는 동적인 자료구조입니다. 배열처럼 연속된 메모리 주소가 없지만 대신 노드(Node)라는게 존재하며 노드안에 데이터가 있고 다음 데이터의 주소가 들어있습니다. 장점으로는 크기의 제한이 없어 데이터의 추가, 삭제가 자유롭습니다. 하지만 단점으로는 연속적인 메모리 주소를 받지 않았기 때문에 임의 탐색이 불가능합니다. 노드를 이용해 순차적으로 접근할 수 밖에 없습니다.

- **정렬 알고리즘 중 퀵 정렬(Quick Sort)과 병합 정렬(Merge Sort)의 시간 복잡도와 차이점에 대해 설명해 주세요.**
> 퀵 정렬은 임의의 기준값인 피벗값을 중심으로 값이 작은 배열과 큰 배열로 정렬합니다. 이렇게 나누어진 각 그룹에서 같은 과정을 반복하여 하나의 원소가 남을때 까지 반복하여 정렬합니다. 시간복잡도는 평균적인 경우 O(n log n)이며 최악의 경우(기준값이 최대 or 최소인 피벗에 의한 분할이 1개, n-1개의 그룹 반복) O(n^2)입니다. 데이터의 분포에 따라 달라지므로 불안정한 정렬입니다.
   
 >병합 정렬은 입력 배열을 크기가 1이 될때까지 계속 반으로 나눈뒤 나누어진 배열을 두개 씩 비교하면서 정렬된 상태로 합칩니다. 병합정렬의 시간복잡도는 O(n log n)의 시간 복잡도를 보장하므로 안정적인 정렬입니다. 하지만 정렬된 하위 배열들을 보관하기 위한 임시 배열이 필요하여 메모리 낭비가 발생할 수 있습니다.

### **데이터베이스**

- **관계형 데이터베이스와 NoSQL 데이터베이스의 차이점에 대해 설명해 주세요.**
> 관계형 데이터베이스는 사전에 정의된 관계(스키마)로 데이터를 행과 열로 구성된 데이터를 가리킵니다. 각 행은 Primary Key라는 고유 식별자로 구별할 수 있으며 이 키를 Foriegn Key로 설정하여 여러 테이블들을 연결 할 수 있습니다.

> No SQL데이터베이스는 주로 스키마가 고정되어 있지 않은 데이터를 가리킵니다. 관계형 DB와는 다르게 융퉁성 있는 데이터 모델을 사용하며 데이터 구조에 따라 key-value형, Document-oriented형, graph형 등 여러가지가 있습니다.
- **SQL에서 조인(Join)의 종류와 각각의 특징에 대해 설명해 주세요.**
> 1. INNER JOIN - 두 테이블에 공통된 조인 키 값만 있는 행만 조인해서 반환합니다.
> 2. OUTER JOIN - LEFT JOIN, RIGHT JOIN, FULL JOIN이 있으며 한쪽 또는 양쪽 테이블의 모든 데이터를 포함하면서 공통된  키가 없을 경우 NULL을 채워 반환합니다.
> 3. CROSS JOIN - 카디션 곱이라고도 하며 한쪽 에티블의 모든행과 다른 쪽 테이블의 모든 행을 조인합니다. 모두 조합하므로 두 테이블의 각 행의 개수를 곱한 값만큼 결과 행의 개수가 됩니다.
> 4. SELF JOIN - 자기 자신과 조인합니다. 별칭을 사용하여 같은 테이블을 두 개처럼 활용할 수 있습니다.

### **운영체제**

- **운영체제에서 프로세스와 스레드의 차이점은 무엇인가요?**
> 프로세스는 운영체제로부터 할당받은 작업의 단위을 말합니다. 프로그램이 실행되어 메모리에 올라갈 때 운영체제로부터 독립된 메모리 영역을 할당받게 됩니다. 서로 독립적이기 때문에 서로 다른 프로세스간에 메모리 영역(Code, Data, Stack, Heap)을 공유하지 않습니다. 프로세스는 최소 1개의 스레드를 가집니다.
   스레드는 프로세스 내에서 실행되는 작은 단위로 프로세스가 할당받은 자원을 이용하여 실행됩니다. 스레드는 프로세스내에서 각각 Stack만 따로 할당되며 Code, Data, Heap영역은 서로 공유합니다.
### **네트워크**

- **HTTP와 HTTPS의 차이점에 대해 설명해 주세요.**
> HTTP와 HTTPS는 넷상에서 데이터를 주고받는데 사용되는 프로토콜입니다. HTTPS의 S는 Secure로 이 둘의 차이점은 보안입니다. HTTP는 암호화되지 않은 텍스트데이터를 전송하며 도중에 중간자의 공격이나 도난, 변조가 발생할 수 있습니다. HTTPS는 HTTP의 암호화된 버전으로 SSL이나 TLS를 이용하여 인증하는 과정을 거칩니다. 이 과정을 통해 도중에 누군가가 가로채어도 정보를 해독하기 어렵고 데이터의 무결성을 보장할 수 있습니다.

### **컴퓨터 아키텍처**

- **컴퓨터 시스템에서 캐시(Cache)의 역할과 작동 원리에 대해 설명해 주세요.**
> 캐시는 데이터를 빠르게 제공하기 위한 고속 메모리입니다. 메모리 계층 구조상에서 레지스터와 메모리 사이에 있으며 cpu나 메모리 또는 저장장치 간의 간극을 줄이는 *완충재 역할*을 합니다. 캐시메모리가 역할을 제대로 수행하기 위해서는 CPU가 어떤 데이터를 원할 지를 예측할 수 있어야 합니다. 캐시의 성능은 작은 캐시 메모리에 CPU가 참조할 정보가 어느정도 들어있는지데 따라 달라지기 때문입니다. 이 때 *Hit rate를 극대화*시키기 위해 데이터 지역성을 이용합니다. 프로그램은 일반적으로 모든 데이터를 균일하게 접근하지 않는다는 특성을 이용합니다. *데이터 지역성*은 시간 지역성과 공간 지역성으로 나뉩니다. *시간 지역성*은 *한번 참조된 데이터는 잠시 후에 또 참조될 가능성이 높은 특성*입니다. 메모리상 같은 주소를 여러 차례 읽기 쓰기를 할 경우 상대적으로 작은 크기의 캐시를 사용해도 효율을 높일 수 있습니다. *공간 지역성*은 기억장치 내에 *서로 인접하여 저장되어 있는 데이터들이 연속적으로 접근할 가능성이 높은 특성*입니다. CPU 캐시나 디스크 캐시의 경우 한 메모리 주소에 접근 할 때 그 주소뿐만 아니라 해당 블록을 전부 캐시에 가져오게 됩니다. 이때 메모리 주소를 오름차순이나 내림차순으로 접근한다면, 캐시에 이미 저장된 같은 블록의 데이터를 접근하게 되므로 캐시의 효율성이 크게 향상된다.
- **CPU와 GPU의 차이점과 각각의 장단점에 대해 설명해 주세요.**
> cpu는 최상의 계층의 중장처리장치로 컴퓨터의 두뇌역할을 담당합니다. 데이터처리와 더불어 어플리케이션에서 분석한 알고리즘에 따라 다음 행동을 결정하고 멀티태스킹을 위해 나눈 작업들에 우선순위를 지정하고 전환하며 가상 메모리를 관리하는 등 컴퓨터를 지위하는 역할을 합니다.
> gpu는 픽셀로 이루어진 영상을 처리하는 용도로 탄생했습니다. 반복적이고 비슷한 대량 연산을 병렬적으로 수행하기 떄문에 영상 렌더링이나 그래픽 작업에서는 CPU보다 훨씬 빠르게 처리할 수 있습니다.

### **소프트웨어 공학**

- **애자일(Agile) 개발 방법론이란 무엇이며, 스크럼(Scrum)과 칸반(Kanban)의 차이점은 무엇인가요?**
> 애자일은 요구 사항들을 민첩하고 기민하게 충족시켜 개발하자는 방법론입니다. 아주 작은 핵심 요소만으로 제품 또는 샘플을 만들어서 소비자의 반응을 확인하고 점점 살을 붙여 나가는 방식으로 사용자의 반응을 보면서 변화하는 요구사항에 신속히 대응하는 데 중점을 둡니다. 애자일 프레임워크에는 대표적으로 스크럼과 칸반이 있습니다.

> 칸반은 팀과 조직의 작업을 시각화하여 업무의 병목 현상과 리소스 낭비를 처리할 수 있도록 돕는 애자일 프로젝트를 관리하는 하나의 유형입니다. 고정된 주기(Sprint)없이 팀이 현재 진행중인 작업을 효율적으로 관리하는데 집중합니다.

> 스크럼은 팀이 중심이 되어 개발의 효율성을 높이는 일종의 프로세스 프레임워크입니다. 일정한 주기(Sprint)로 명확한 목표를 설정하고 개발이 끝나면 리뷰 및 회고를 통해 지속적으로 개선합니다.
- **버전 관리 시스템(Git)의 기본 개념과 주요 명령어에 대해 설명해 주세요.**
> Git은 코드의 변경 사항을 추적하고 협업을 돕는 분산 버전 관리 시스템(DVCS)으로, 코드의 변경 사항을 추적하고 여러 개발자가 협업할 수 있도록 돕는 도구입니다. 로컬과 원격 저장소를 사용하여 변경 이력을 관리거나 이전 버전으로 되돌리거나 여러 브랜치를 만들어 개발할 수 있습니다. 저장소를 만들 때 `git init`으로 초기화하거나 `git clone <URL>`로 복제하며, 파일을 수정한 후 `git add <파일명>`으로 스테이징하고 `git commit -m "메시지"`로 커밋합니다. 변경 사항을 원격 저장소에 반영하려면 `git push origin <브랜치명>`, 원격 저장소의 최신 변경 사항을 가져오려면 `git pull origin <브랜치명>`을 사용합니다. 독립적인 작업을 위해 `git branch <브랜치명>`으로 새 브랜치를 만들고 `git switch <브랜치명>`으로 전환하며, 작업 완료 후 `git merge <브랜치명>`으로 병합할 수 있습니다. 변경 이력은 `git log`로 확인하고, 이전 상태로 되돌리려면 `git reset` 또는 `git revert`를 활용할 수 있습니다. Git을 활용하면 코드의 버전을 체계적으로 관리하고 협업 시 충돌을 최소화할 수 있습니다.

### **컴파일러**

- **컴파일러와 인터프리터의 차이점은 무엇인가요?**
> 컴파일러와 인터프리터는 *고급 프로그래밍 언어*를 컴퓨터가 이해할 수 있는 *어셈블리언어로 번역해주는 2가지방식*입니다.

> 컴파일러는 소스코드 *전체를 한 번에 모두 기계어*로 변환합니다. 전체를 스캔하기 때문에 컴파일러는 *초기 스캔 시간이 오래* 걸립니다. 하지만 초기 스캔을 끝낸 뒤에 실행 파일을 생성하고 다음에 실행할 때는 *이전에 만들어둔 실행 파일*을 실행하기 때문에 전체 실행시간은 빠릅니다. 실행 속도가 *빠르지만 고급 언어로 작성된 기계어로 번역*하고 이 과정에서 오브젝트 코드라는 파일을 만들며 오브젝트 코드를 묶어서 하나의 실행파일을 만드는 링킹작업을 거쳐야 하므로 일반적으로 인터프리터에 비해 많은 메모리가 필요합니다. 컴파일러는 에러 검사를 컴파일 단계에서 수행하므로 실행 전 오류를 확인할 수 있습니다. 대표적인 언어로 C,C++,JAVA 등이 있습니다.

> 인터프리터는 컴파일러와 반대로 프로그램 실행 시 *소스코드를 한 줄씩 즉시 해석*합니다. 그렇기 때문에 한번에 전체를 스캔하고 실행파일을 만들어서 실행하는 컴파일러보다 실행시간이 더 걸립니다. 컴파일러와 다르게 링킹 과정이 없기 때문에 메모리 사용에 있어서 효율적인 모습을 보입니다. *코드 수정 후 즉시 실행할 수 있어 디버깅*에 용이합니다. 대표적인 언어로 Python, Javascript, Ruby 등이 있습니다. 
- **코드 최적화(Code Optimization)란 무엇이며, 그 중요성에 대해 설명해 주세요.**
> 코드 최적화란 주어진 코드에 대해서 프로그램의 실행 속도를 높이거나 메모리 사용량을 줄이는 등 성능을 개선하기 위해 코드 구조를 최적화하는 과정입니다. 웹 애플리케이션의 로딩 속도를 빠르게 하거나 게임에서 프레임 드랍이 줄어드는 효과를 얻어 사용자 경험에 기여할 수 있습니다. 뿐만 아니라, 최적화는 대량의 데이터를 처리하는 프로그램에서 병목 현상을 줄이고 확장성을 높이는 역할을 합니다. 하지만 과도한 최적화는 코드의 가독성을 해치고 유지보수를 어렵게 만들 수 있기 때문에 성능향상과 코드 품질의 균형을 유지하는 것이 중요합니다.

### **보안**

- **대칭 키 암호화와 비대칭 키 암호화의 차이점에 대해 설명해 주세요.**
> 대칭 키 암호화는 *하나의 동일한 키*를 사용하여 *데이터를 암호화하고 복호화하는* 방식을 말합니다. *속도가 빠르고 구현이 간단*하다는 장점이 있지만 키가 유출되면 누구나 복호화할 수 있기 때문에 키관리가 중요한 단점이 있습니다. 대표적인 알고리즘으로는 AES, DES, 3DES등이 있으며 주로 파일 암호화, 데이터베이스 보안, VPN 등에서 사용됩니다. 반면 비대칭 키 암호화는 암호화, 복호화에 사용하는 키가 서로 다른 방식을 말합니다. 공개 키와 개인 키 한쌍을 사용하여 수행하며 개인 키는 외부에 절대로 노출하지 않는 방식이기 때문에 키공유가 안전하다는 장점이 있습니다. 하지만 비대칭 키 암호화는 연산 속도가 느려 데이터 전송 보다는 키 교환이나 인증 과정에서 많이 사용됩니다. 대표적인 알고리즘으로는 RSA, ECC, Diffie-Hellman등이 있습니다.
- **해시 함수(Hash Function)의 주요 특징과 사용 사례에 대해 설명해 주세요.**
> 해시 함수는 임의의 길이의 데이터를 고정된 데이터로 매핑하는 함수입니다. 이때 매핑된 결과를 해시 값 또는 해시 코드라 부릅니다. 주요 특징으로는 입력 데이터의 크기에 관계없이 고정된 크기를 출력하며 같은 입력 값에 대해서는 항상 같은 결과 값이 출력됩니다(결정론적). 또한 출력 값을 통해 입력 값을 유추할 수 없습니다(단방향). 이러한 특성을 이용하여 파일 다운로드 후 무결성 검증, 비밀번호를 해시화하여 데이터베이스가 저장, 블록체인에서 해시값 비교를 통해 위변조를 판별 등에 사용됩니다.

### **데이터베이스 설계**

- **정규화(Normalization)란 무엇이며, 제1 정규형(1NF), 제2 정규형(2NF), 제3 정규형(3NF)에 대해 설명해 주세요.**
> 데이터의 정규화는 데이터베이스에서 데이터의 중복을 최소화하고 무결성을 유지하기 위해 데이터를 구조화하는 과정입니다.

> 제 1 정규화란 테이블의 컬럼이 원자값(하나만 존재하는 값)을 갖도록 분해하는 것입니다. 각 컬럼은 하나의 값만 존재해야 하며 중복되는 데이터가 없어야 합니다.

> 제 2 정규화란 제 1 정규화를 진행한 테이블에 대해 부분적 함수 종속이 없도록 하는 것입니다. 부분적 함수 종속이란 기본 키의 일부분만 결정자가 되어선 안된다는 것을 의미합니다.

| 학생번호 | 과목코드 | 과목명 | 교수명 |
| :--: | :--: | :-: | :-: |
| 101  | M101 | 수학  | 김교수 |
| 101  | P102 | 물리  | 이교수 |
| 102  | M101 | 수학  | 김교수 |
> 기본 키가 학생번호, 과목코드인 복합 키인 상황에서 과목명과 교수명은 과목코드에 종속되지만 학생번호와는 전혀 관련이 없습니다. 다시말하면 기본키의 일부분인 과목코드에 의해 결정되는 부분함수 종족이 존재합니다. 이 테이블을 분리하게 되면

| 학생번호 | 과목코드 |
| :--: | :--: |
| 101  | M101 |
| 101  | P102 |
| 102  | M101 |

| 과목코드 | 과목명 | 교수명 |
| :--: | :-: | :-: |
| M101 | 수학  | 김교수 |
| P102 | 물리  | 이교수 |
> 이와 같이 부분 함수 종속을 사라지게 할 수 있습니다.

> 제 3정규형은 제 2정규형을 만족하면서 이행적 함수 종속이 없어야 합니다. 

| 주문번호 | 고객명 | 고객주소 |
| :--: | :-: | :--: |
|  1   |  A  |  서울  |
|  2   |  B  |  인천  |
> 여기서 이행적 함수 종속이란 다음과 같이 주문번호 => 고객, 고객=>고객주소에서 주문번호 => 고객주소로 종속되는 상황을 말합니다. 이를 없애기 위해 분리하면


| 주문번호 | 고객명 |
|:--------:|:------:|
|    1     |   A    |
|    2     |   B    |

| 고객명 | 고객주소 |
| :-: | :--: |
|  A  |  서울  |
|  B  |  인천  |

> 다음과 같이 주분번호를 통해 고객명을 참고하고, 고객명으로 고객 주소를 참조하도록 테이블을 분해해야 합니다.


- **데이터베이스 인덱스(Database Index)의 역할과 사용 방법에 대해 설명해 주세요.**
> 데이터베이스 인덱스란 검색 속도를 향상시키기 위해 테이블의 특정 컬럼에 대해 별도로 생성된 데이터 구조입니다. 예를 들어 책에서 원하는 내용을 찾을 때 모든 페이지를 찾는 것보다 목차(index)를 보고 찾는 편이 빠른 것과 같습니다. 

> 사용 방법은 다음과 같습니다.

```
-- 기본 인덱스 생성
CREATE INDEX idx_user_name ON users(name);
-- 복합 인덱스 생성 (name과 age를 함께 검색할 경우 유용)
CREATE INDEX idx_user_name_age ON users(name, age);
-- MySQL에서 사용 가능한 인덱스 확인
SHOW INDEX FROM users;
```

### **소프트웨어 디자인 패턴**

- **디자인 패턴(Design Pattern)이란 무엇이며, 싱글톤(Singleton) 패턴에 대해 설명해 주세요.**
> 디자인 패턴은 개발하면서 발생하는 반복적인 문제들에 대해 어떻게 해결할 것인지에 대한 해결방안으로 다양한 해결책 중에 많은 사람들이 사용하고 있는 모범 사례들을 말합니다.

> 패턴 중 하나인 싱글톤 패턴은 하나의 클래스로부터 생성된 인스턴스를 전역에서 접근 가능하게 하면서 해당 인스턴스가 한 번만 생성되도록 보장하는 패턴을 말합니다. 하나의 인스턴스만 사용하므로 메모리 낭비를 방지할 수 있으며 생성된 인스턴스를 재활용하기 때문에 속도 측면에서도 이점이 있습니다. 또한 전역으로 사용하기 때문에 데이터를 쉽게 공유할 수 있습니다.

- **MVC(Model-View-Controller) 패턴의 구성 요소와 작동 원리에 대해 설명해 주세요.**
> MVC패턴이란 디자인 패턴들 중 하나로 주로 UI를 가진 어플리케이션에서 사용됩니다. 애플리케이션의 개발, 유지보수를 쉽게 하기 위해 Model, View, Controller 3 가지 영역으로 분리합니다. 

> Model은 어플리케이션의 핵심 데이터와 비즈니스 로직을 나타냅니다. DB와의 상호작용, 데이터 처리 및 유효성 검사와 같은 작업을 수행합니다. 뷰, 컨트롤러와 직접적으로 상호작용하지 않습니다.

> View는 사용자에게 보여지는 어플리케이션의 UI부분을 말합니다. 데이터 표시와 관련된 모든 작업을 처리합니다. 모델에서 데이터를 받아 사용자에게 표시하고 입력을 컨트롤러에 전달하는 역할을 합니다.

> Controller는 사용자 입력을 처리하고 어플리케이션의 흐름을 관리합니다. 뷰에서 전달된 사용자 입력을 분석하고 모델 기능을 호출하여 데이터를 업데이트합니다. 그 후 결과를 다시 뷰에 전달하여 화면에 표시할 수 있습니다.



# 공통 예상 질문 정리

## 자기소개

반갑습니다 이번 {회사이름}에 지원하게된 '이다익'입니다.

**대학을 다니기 이전**부터 **웹이나 앱의 UI 요소에 관심**이 많았었습니다.
직접 **디자인**을 해보기도 하고 만든 디자인에 관해서 다른 사용자들에게 보여주고 **피드백을 받아보기도** 하였습니다.
그러다가 **유튜브에서 디자인과 여러가지 기능을 html, css, JavaScript로 구현**하는 영상을 **직접 따라하면서 처음으로 개발을 접**하게 되었습니다.

처음에는 **튜토리얼** 영상들을 따라하면서 진행하다가 어느정도 **익숙해진 뒤**에는 **평소에 만들어보고 싶었던 제품**들을 직접 개발하면서 **필요한 기술들을 학습**하였습니다.
이 과정에서 개발에 대한 적성을 발견하게 되서 개발자로써의 진로를 정하게 되었습니다.

이러한 경험을 바탕으로 회사와 모든 사용자들에게 가치를 전달하는 개발자가 되겠습니다. 
감사합니다.

## 프로젝트 도중 갈등 해결 경험

보드게임 프로젝트 **시작**할 때 갈등이 있었습니다. 제가 프로젝트를 시작할 때 **벡앤드가 어느정도 개발이 되어있는 상황**이었습니다. **그런데** 게임과 관련된 기능들이 모두 **REST API로 구현**되어 있었습니다. 저희가 개발할 게임은 시간과 **상대방의 현재 상태가 매우 중요**했었는데 일일히 요청해서 정보를 가져와야하는 REST API의 특성상 이 정보들을 **최신 상태로 유지**하는 것에서 **한계**가 있었습니다. **그래서 REST API가 아닌 WebSocket을** 이용하여 **다시 개발하는 방법을 제안**했었습니다. 그러나 백엔드 개발자분께서 **WebSocket을 이용해본 경험**이 없어 **기존 방식을 유지**하려고 하셨고 이로 인해 갈등이 있었습니다. 이 갈등을 해결하기 위해 기존 **REST API방식으로 구현했을 때 문제점**과 **WebSocket으로 구현했을 때의 장단점**을 토대로 설득을 하였고 백엔드 개발자분께서 WebSocket의 필요성을 이해하시고, 함께 학습하며 적용하기로 **합의하여 해결**했습니다.

## 언제부터 출근 가능하시나요

현재 특별한 일정이 없어서 바로 합류할 수 있습니다.

## 프론트엔드를 선택한 이유

이전부터 디자인이나 UI요소에 관심이 많았었고 제가 만든 기능들이 많은 사용자들에게 실행되는 것에 만족감을 느껴서 성취감을 느껴서 선택하게 되었습니다.


## 기술면접
### var, let, const의 차이

**var**의 경우 **es6 이전에 존재**했던 변수 선언 방법으로 **중복 선언, 재할당**이 모두 가능합니다. 하지만 **코드가 길어질 수록 관리**하기 어려우며 **에러가 발생한 위치**를 찾기도 힘들어집니다. 또한 var로 변수를 선언할 경우 **먼저 undefined로 초기화되어 호이스팅**되므로 실제 값이 할당되기 이전에 로그를 출력해보면 undefined로 출력이 됩니다.

let은 es6이후로 나온 변수 선언 방법으로 중복 선언은 불가능하지만 재할당은 가능합니다. 
const도 es6이후로 나온 변수 선언 방법으로 중복 선언과 재할당이 모두 불가능합니다. 

let과 const는 TDZ라는 제약을 받습니다. 선언되기 전에 접근할 경우 참조에러가 발생합니다.

### 비동기 함수에 대해 설명해주세요

비동기 함수란 함수의 실행 결과가 즉시 반환되지 않고, 특정 조건이 충족될 때까지 기다리는 함수입니다. 비동기 함수는 일반적으로 콜백 함수나 Promise 객체를 반환하는데요, 콜백 함수는 비동기 작업이 완료되었을 때 호출되고, Promise 객체는 비동기 작업이 성공했는지 혹은 실패했는지를 나타냅니다.  
비동기 함수를 잘 사용하면 서비스의 성능과 반응성을 잘 유지할 수 있으나, 콜백 지옥이 발생할 수 있으므로 Promise의 후속 처리 메서드(then, catch, finally)나 async, await를 이용하여 적절하게 코드를 구성하는 것이 필요합니다.  
여러개의 비동기 함수가 실행되면 이벤트 루프는 비동기 함수 호출을 처리하고, 비동기 함수가 완료되었을 때 콜백 함수를 호출합니다. 이벤트 루프는 실행 대기 중인 비동기 함수가 있으면 해당 함수를 호출하고, 실행이 완료될 때까지 다음 비동기 함수를 호출합니다. 즉, 여러 개의 비동기 함수가 실행될 때 이 함수는 동시에 실행되며, 이벤트 루프에 의해 비동기 함수의 실행순서가 제어된다고 할 수 있습니다.

### 대칭키


참고
https://velog.io/@tbs01215/%EC%8B%A0%EC%9E%85-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%B7%A8%EC%A4%80%EC%83%9D-%EC%B2%AB%EB%B2%88%EC%A7%B8-%EB%A9%B4%EC%A0%91-%EB%B6%88%ED%95%A9-%EA%B8%B0%EB%A1%9D

# 위로드엑스 면접 준비

### 우리회사 솔루션에 대해

스마트폰 카메라로 작업현장을 비추면 필요한 데이터들이 겹쳐서 바로 표시되는 솔루션, 별도의 문서를 찾을 필요가 없어짐

시설물의 상태를 실시간으로 모니터링

=>작업현장과 관련된 솔루션